(* You are given an integer array nums.

A tuple (i, j, k) of 3 distinct indices is good if nums[i] == nums[j] == nums[k].

The distance of a good tuple is abs(i - j) + abs(j - k) + abs(k - i), where abs(x) denotes the absolute value of x.

Return an integer denoting the minimum possible distance of a good tuple. If no good tuples exist, return -1.

 

Example 1:

Input: nums = [1,2,1,1,3]

Output: 6

Explanation:

The minimum distance is achieved by the good tuple (0, 2, 3).

(0, 2, 3) is a good tuple because nums[0] == nums[2] == nums[3] == 1. Its distance is abs(0 - 2) + abs(2 - 3) + abs(3 - 0) = 2 + 1 + 3 = 6.©leetcode
 *)
---------------------------------------------------------------------------------------------------------------------------------------------------------------
(* explaination:-
  first observe the array that as give to you:-small test cases
  then take a map and store the similar element index in a vector
  and ferch the vector one by one in while the vector size of greater then 3 or equal to 3
  then again ferch only three three index one by one and caluculate the  abs(i - j) + abs(j - k) + abs(k - i).
  After all the caluculation of the vector then calucate minimum values of the caluculation so,
  return thr minimum values else return -1; *)

(* //Minimum Distance Between Three Equal Elements. *)
class Solution {
public:
    int minimumDistance(vector<int>& nums) {
        map<int,vector<int>>m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]].push_back(i);
        }
        int ans=INT_MAX;
        for(auto &p:m){
            vector<int>&v=p.second;
            if(v.size()<3)continue;
            for(int i=0;i+2<v.size();i++){
                int a=abs(v[i]-v[i+1])+abs(v[i+1]-v[i+2])+abs(v[i+2]-v[i]);
                ans=min(ans,a);
            }
        }
        return ans==INT_MAX?-1:ans;
    }
};
